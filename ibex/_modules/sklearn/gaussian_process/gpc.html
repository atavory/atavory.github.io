
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>sklearn.gaussian_process.gpc &#8212; ibex latest documentation</title>
    <link rel="stylesheet" href="../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     'latest',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../../../_static/logo.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for sklearn.gaussian_process.gpc</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Gaussian processes classification.&quot;&quot;&quot;</span>

<span class="c1"># Authors: Jan Hendrik Metzen &lt;jhm@informatik.uni-bremen.de&gt;</span>
<span class="c1">#</span>
<span class="c1"># License: BSD 3 clause</span>

<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">operator</span> <span class="k">import</span> <span class="n">itemgetter</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="k">import</span> <span class="n">cholesky</span><span class="p">,</span> <span class="n">cho_solve</span><span class="p">,</span> <span class="n">solve</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="k">import</span> <span class="n">fmin_l_bfgs_b</span>
<span class="kn">from</span> <span class="nn">scipy.special</span> <span class="k">import</span> <span class="n">erf</span><span class="p">,</span> <span class="n">expit</span>

<span class="kn">from</span> <span class="nn">sklearn.base</span> <span class="k">import</span> <span class="n">BaseEstimator</span><span class="p">,</span> <span class="n">ClassifierMixin</span><span class="p">,</span> <span class="n">clone</span>
<span class="kn">from</span> <span class="nn">sklearn.gaussian_process.kernels</span> \
    <span class="kn">import</span> <span class="nn">RBF</span><span class="o">,</span> <span class="nn">CompoundKernel</span><span class="o">,</span> <span class="nn">ConstantKernel</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">from</span> <span class="nn">sklearn.utils.validation</span> <span class="k">import</span> <span class="n">check_X_y</span><span class="p">,</span> <span class="n">check_is_fitted</span><span class="p">,</span> <span class="n">check_array</span>
<span class="kn">from</span> <span class="nn">sklearn.utils</span> <span class="k">import</span> <span class="n">check_random_state</span>
<span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="k">import</span> <span class="n">LabelEncoder</span>
<span class="kn">from</span> <span class="nn">sklearn.multiclass</span> <span class="k">import</span> <span class="n">OneVsRestClassifier</span><span class="p">,</span> <span class="n">OneVsOneClassifier</span>


<span class="c1"># Values required for approximating the logistic sigmoid by</span>
<span class="c1"># error functions. coefs are obtained via:</span>
<span class="c1"># x = np.array([0, 0.6, 2, 3.5, 4.5, np.inf])</span>
<span class="c1"># b = logistic(x)</span>
<span class="c1"># A = (erf(np.dot(x, self.lambdas)) + 1) / 2</span>
<span class="c1"># coefs = lstsq(A, b)[0]</span>
<span class="n">LAMBDAS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.41</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.37</span><span class="p">,</span> <span class="mf">0.44</span><span class="p">,</span> <span class="mf">0.39</span><span class="p">])[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
<span class="n">COEFS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">1854.8214151</span><span class="p">,</span> <span class="mf">3516.89893646</span><span class="p">,</span> <span class="mf">221.29346712</span><span class="p">,</span>
                  <span class="mf">128.12323805</span><span class="p">,</span> <span class="o">-</span><span class="mf">2010.49422654</span><span class="p">])[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">_BinaryGaussianProcessClassifierLaplace</span><span class="p">(</span><span class="n">BaseEstimator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Binary Gaussian process classification based on Laplace approximation.</span>

<span class="sd">    The implementation is based on Algorithm 3.1, 3.2, and 5.1 of</span>
<span class="sd">    ``Gaussian Processes for Machine Learning&#39;&#39; (GPML) by Rasmussen and</span>
<span class="sd">    Williams.</span>

<span class="sd">    Internally, the Laplace approximation is used for approximating the</span>
<span class="sd">    non-Gaussian posterior by a Gaussian.</span>

<span class="sd">    Currently, the implementation is restricted to using the logistic link</span>
<span class="sd">    function.</span>

<span class="sd">    .. versionadded:: 0.18</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    kernel : kernel object</span>
<span class="sd">        The kernel specifying the covariance function of the GP. If None is</span>
<span class="sd">        passed, the kernel &quot;1.0 * RBF(1.0)&quot; is used as default. Note that</span>
<span class="sd">        the kernel&#39;s hyperparameters are optimized during fitting.</span>

<span class="sd">    optimizer : string or callable, optional (default: &quot;fmin_l_bfgs_b&quot;)</span>
<span class="sd">        Can either be one of the internally supported optimizers for optimizing</span>
<span class="sd">        the kernel&#39;s parameters, specified by a string, or an externally</span>
<span class="sd">        defined optimizer passed as a callable. If a callable is passed, it</span>
<span class="sd">        must have the  signature::</span>

<span class="sd">            def optimizer(obj_func, initial_theta, bounds):</span>
<span class="sd">                # * &#39;obj_func&#39; is the objective function to be maximized, which</span>
<span class="sd">                #   takes the hyperparameters theta as parameter and an</span>
<span class="sd">                #   optional flag eval_gradient, which determines if the</span>
<span class="sd">                #   gradient is returned additionally to the function value</span>
<span class="sd">                # * &#39;initial_theta&#39;: the initial value for theta, which can be</span>
<span class="sd">                #   used by local optimizers</span>
<span class="sd">                # * &#39;bounds&#39;: the bounds on the values of theta</span>
<span class="sd">                ....</span>
<span class="sd">                # Returned are the best found hyperparameters theta and</span>
<span class="sd">                # the corresponding value of the target function.</span>
<span class="sd">                return theta_opt, func_min</span>

<span class="sd">        Per default, the &#39;fmin_l_bfgs_b&#39; algorithm from scipy.optimize</span>
<span class="sd">        is used. If None is passed, the kernel&#39;s parameters are kept fixed.</span>
<span class="sd">        Available internal optimizers are::</span>

<span class="sd">            &#39;fmin_l_bfgs_b&#39;</span>

<span class="sd">    n_restarts_optimizer: int, optional (default: 0)</span>
<span class="sd">        The number of restarts of the optimizer for finding the kernel&#39;s</span>
<span class="sd">        parameters which maximize the log-marginal likelihood. The first run</span>
<span class="sd">        of the optimizer is performed from the kernel&#39;s initial parameters,</span>
<span class="sd">        the remaining ones (if any) from thetas sampled log-uniform randomly</span>
<span class="sd">        from the space of allowed theta-values. If greater than 0, all bounds</span>
<span class="sd">        must be finite. Note that n_restarts_optimizer=0 implies that one</span>
<span class="sd">        run is performed.</span>

<span class="sd">    max_iter_predict: int, optional (default: 100)</span>
<span class="sd">        The maximum number of iterations in Newton&#39;s method for approximating</span>
<span class="sd">        the posterior during predict. Smaller values will reduce computation</span>
<span class="sd">        time at the cost of worse results.</span>

<span class="sd">    warm_start : bool, optional (default: False)</span>
<span class="sd">        If warm-starts are enabled, the solution of the last Newton iteration</span>
<span class="sd">        on the Laplace approximation of the posterior mode is used as</span>
<span class="sd">        initialization for the next call of _posterior_mode(). This can speed</span>
<span class="sd">        up convergence when _posterior_mode is called several times on similar</span>
<span class="sd">        problems as in hyperparameter optimization.</span>

<span class="sd">    copy_X_train : bool, optional (default: True)</span>
<span class="sd">        If True, a persistent copy of the training data is stored in the</span>
<span class="sd">        object. Otherwise, just a reference to the training data is stored,</span>
<span class="sd">        which might cause predictions to change if the data is modified</span>
<span class="sd">        externally.</span>

<span class="sd">    random_state : int, RandomState instance or None, optional (default: None)</span>
<span class="sd">        The generator used to initialize the centers. If int, random_state is</span>
<span class="sd">        the seed used by the random number generator; If RandomState instance,</span>
<span class="sd">        random_state is the random number generator; If None, the random number</span>
<span class="sd">        generator is the RandomState instance used by `np.random`.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    X_train_ : array-like, shape = (n_samples, n_features)</span>
<span class="sd">        Feature values in training data (also required for prediction)</span>

<span class="sd">    y_train_ : array-like, shape = (n_samples,)</span>
<span class="sd">        Target values in training data (also required for prediction)</span>

<span class="sd">    classes_ : array-like, shape = (n_classes,)</span>
<span class="sd">        Unique class labels.</span>

<span class="sd">    kernel_ : kernel object</span>
<span class="sd">        The kernel used for prediction. The structure of the kernel is the</span>
<span class="sd">        same as the one passed as parameter but with optimized hyperparameters</span>

<span class="sd">    L_ : array-like, shape = (n_samples, n_samples)</span>
<span class="sd">        Lower-triangular Cholesky decomposition of the kernel in X_train_</span>

<span class="sd">    pi_ : array-like, shape = (n_samples,)</span>
<span class="sd">        The probabilities of the positive class for the training points</span>
<span class="sd">        X_train_</span>

<span class="sd">    W_sr_ : array-like, shape = (n_samples,)</span>
<span class="sd">        Square root of W, the Hessian of log-likelihood of the latent function</span>
<span class="sd">        values for the observed labels. Since W is diagonal, only the diagonal</span>
<span class="sd">        of sqrt(W) is stored.</span>

<span class="sd">    log_marginal_likelihood_value_ : float</span>
<span class="sd">        The log-marginal-likelihood of ``self.kernel_.theta``</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kernel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">optimizer</span><span class="o">=</span><span class="s2">&quot;fmin_l_bfgs_b&quot;</span><span class="p">,</span>
                 <span class="n">n_restarts_optimizer</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_iter_predict</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
                 <span class="n">warm_start</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">copy_X_train</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kernel</span> <span class="o">=</span> <span class="n">kernel</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optimizer</span> <span class="o">=</span> <span class="n">optimizer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_restarts_optimizer</span> <span class="o">=</span> <span class="n">n_restarts_optimizer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_iter_predict</span> <span class="o">=</span> <span class="n">max_iter_predict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">warm_start</span> <span class="o">=</span> <span class="n">warm_start</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">copy_X_train</span> <span class="o">=</span> <span class="n">copy_X_train</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">random_state</span>

    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fit Gaussian process classification model</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : array-like, shape = (n_samples, n_features)</span>
<span class="sd">            Training data</span>

<span class="sd">        y : array-like, shape = (n_samples,)</span>
<span class="sd">            Target values, must be binary</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self : returns an instance of self.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># Use an RBF kernel as default</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kernel_</span> <span class="o">=</span> <span class="n">C</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">constant_value_bounds</span><span class="o">=</span><span class="s2">&quot;fixed&quot;</span><span class="p">)</span> \
                <span class="o">*</span> <span class="n">RBF</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">length_scale_bounds</span><span class="o">=</span><span class="s2">&quot;fixed&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kernel_</span> <span class="o">=</span> <span class="n">clone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kernel</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rng</span> <span class="o">=</span> <span class="n">check_random_state</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">X_train_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy_X_train</span> <span class="k">else</span> <span class="n">X</span>

        <span class="c1"># Encode class labels and check that it is a binary classification</span>
        <span class="c1"># problem</span>
        <span class="n">label_encoder</span> <span class="o">=</span> <span class="n">LabelEncoder</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_train_</span> <span class="o">=</span> <span class="n">label_encoder</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">classes_</span> <span class="o">=</span> <span class="n">label_encoder</span><span class="o">.</span><span class="n">classes_</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">classes_</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> supports only binary classification. &quot;</span>
                             <span class="s2">&quot;y contains classes </span><span class="si">%s</span><span class="s2">&quot;</span>
                             <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">classes_</span><span class="p">))</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">classes_</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{0:s}</span><span class="s2"> requires 2 classes.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimizer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel_</span><span class="o">.</span><span class="n">n_dims</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Choose hyperparameters based on maximizing the log-marginal</span>
            <span class="c1"># likelihood (potentially starting from several initial values)</span>
            <span class="k">def</span> <span class="nf">obj_func</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">eval_gradient</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">eval_gradient</span><span class="p">:</span>
                    <span class="n">lml</span><span class="p">,</span> <span class="n">grad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_marginal_likelihood</span><span class="p">(</span>
                        <span class="n">theta</span><span class="p">,</span> <span class="n">eval_gradient</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="k">return</span> <span class="o">-</span><span class="n">lml</span><span class="p">,</span> <span class="o">-</span><span class="n">grad</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">log_marginal_likelihood</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

            <span class="c1"># First optimize starting from theta specified in kernel</span>
            <span class="n">optima</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_constrained_optimization</span><span class="p">(</span><span class="n">obj_func</span><span class="p">,</span>
                                                     <span class="bp">self</span><span class="o">.</span><span class="n">kernel_</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span>
                                                     <span class="bp">self</span><span class="o">.</span><span class="n">kernel_</span><span class="o">.</span><span class="n">bounds</span><span class="p">)]</span>

            <span class="c1"># Additional runs are performed from log-uniform chosen initial</span>
            <span class="c1"># theta</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_restarts_optimizer</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kernel_</span><span class="o">.</span><span class="n">bounds</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Multiple optimizer restarts (n_restarts_optimizer&gt;0) &quot;</span>
                        <span class="s2">&quot;requires that all bounds are finite.&quot;</span><span class="p">)</span>
                <span class="n">bounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel_</span><span class="o">.</span><span class="n">bounds</span>
                <span class="k">for</span> <span class="n">iteration</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_restarts_optimizer</span><span class="p">):</span>
                    <span class="n">theta_initial</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">bounds</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span>
                                                            <span class="n">bounds</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]))</span>
                    <span class="n">optima</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_constrained_optimization</span><span class="p">(</span><span class="n">obj_func</span><span class="p">,</span> <span class="n">theta_initial</span><span class="p">,</span>
                                                       <span class="n">bounds</span><span class="p">))</span>
            <span class="c1"># Select result from run with minimal (negative) log-marginal</span>
            <span class="c1"># likelihood</span>
            <span class="n">lml_values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">optima</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kernel_</span><span class="o">.</span><span class="n">theta</span> <span class="o">=</span> <span class="n">optima</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">lml_values</span><span class="p">)][</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log_marginal_likelihood_value_</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">lml_values</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log_marginal_likelihood_value_</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">log_marginal_likelihood</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kernel_</span><span class="o">.</span><span class="n">theta</span><span class="p">)</span>

        <span class="c1"># Precompute quantities required for predictions which are independent</span>
        <span class="c1"># of actual query points</span>
        <span class="n">K</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel_</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_train_</span><span class="p">)</span>

        <span class="n">_</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pi_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">W_sr_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">L_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">_posterior_mode</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">return_temporaries</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform classification on an array of test vectors X.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : array-like, shape = (n_samples, n_features)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        C : array, shape = (n_samples,)</span>
<span class="sd">            Predicted target values for X, values are from ``classes_``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">check_is_fitted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;X_train_&quot;</span><span class="p">,</span> <span class="s2">&quot;y_train_&quot;</span><span class="p">,</span> <span class="s2">&quot;pi_&quot;</span><span class="p">,</span> <span class="s2">&quot;W_sr_&quot;</span><span class="p">,</span> <span class="s2">&quot;L_&quot;</span><span class="p">])</span>

        <span class="c1"># As discussed on Section 3.4.2 of GPML, for making hard binary</span>
        <span class="c1"># decisions, it is enough to compute the MAP of the posterior and</span>
        <span class="c1"># pass it through the link function</span>
        <span class="n">K_star</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel_</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_train_</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span>  <span class="c1"># K_star =k(x_star)</span>
        <span class="n">f_star</span> <span class="o">=</span> <span class="n">K_star</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y_train_</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">pi_</span><span class="p">)</span>  <span class="c1"># Algorithm 3.2,Line 4</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">f_star</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">classes_</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">classes_</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">predict_proba</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return probability estimates for the test vector X.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : array-like, shape = (n_samples, n_features)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        C : array-like, shape = (n_samples, n_classes)</span>
<span class="sd">            Returns the probability of the samples for each class in</span>
<span class="sd">            the model. The columns correspond to the classes in sorted</span>
<span class="sd">            order, as they appear in the attribute ``classes_``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">check_is_fitted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;X_train_&quot;</span><span class="p">,</span> <span class="s2">&quot;y_train_&quot;</span><span class="p">,</span> <span class="s2">&quot;pi_&quot;</span><span class="p">,</span> <span class="s2">&quot;W_sr_&quot;</span><span class="p">,</span> <span class="s2">&quot;L_&quot;</span><span class="p">])</span>

        <span class="c1"># Based on Algorithm 3.2 of GPML</span>
        <span class="n">K_star</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel_</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_train_</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span>  <span class="c1"># K_star =k(x_star)</span>
        <span class="n">f_star</span> <span class="o">=</span> <span class="n">K_star</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y_train_</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">pi_</span><span class="p">)</span>  <span class="c1"># Line 4</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">W_sr_</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">K_star</span><span class="p">)</span>  <span class="c1"># Line 5</span>
        <span class="c1"># Line 6 (compute np.diag(v.T.dot(v)) via einsum)</span>
        <span class="n">var_f_star</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel_</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;ij,ij-&gt;j&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

        <span class="c1"># Line 7:</span>
        <span class="c1"># Approximate \int log(z) * N(z | f_star, var_f_star)</span>
        <span class="c1"># Approximation is due to Williams &amp; Barber, &quot;Bayesian Classification</span>
        <span class="c1"># with Gaussian Processes&quot;, Appendix A: Approximate the logistic</span>
        <span class="c1"># sigmoid by a linear combination of 5 error functions.</span>
        <span class="c1"># For information on how this integral can be computed see</span>
        <span class="c1"># blitiri.blogspot.de/2012/11/gaussian-integral-of-error-function.html</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">var_f_star</span><span class="p">)</span>
        <span class="n">gamma</span> <span class="o">=</span> <span class="n">LAMBDAS</span> <span class="o">*</span> <span class="n">f_star</span>
        <span class="n">integrals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">alpha</span><span class="p">)</span> \
            <span class="o">*</span> <span class="n">erf</span><span class="p">(</span><span class="n">gamma</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">alpha</span> <span class="o">/</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">+</span> <span class="n">LAMBDAS</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span> \
            <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">var_f_star</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>
        <span class="n">pi_star</span> <span class="o">=</span> <span class="p">(</span><span class="n">COEFS</span> <span class="o">*</span> <span class="n">integrals</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="o">.</span><span class="mi">5</span> <span class="o">*</span> <span class="n">COEFS</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">pi_star</span><span class="p">,</span> <span class="n">pi_star</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>

    <span class="k">def</span> <span class="nf">log_marginal_likelihood</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">eval_gradient</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns log-marginal likelihood of theta for training data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        theta : array-like, shape = (n_kernel_params,) or None</span>
<span class="sd">            Kernel hyperparameters for which the log-marginal likelihood is</span>
<span class="sd">            evaluated. If None, the precomputed log_marginal_likelihood</span>
<span class="sd">            of ``self.kernel_.theta`` is returned.</span>

<span class="sd">        eval_gradient : bool, default: False</span>
<span class="sd">            If True, the gradient of the log-marginal likelihood with respect</span>
<span class="sd">            to the kernel hyperparameters at position theta is returned</span>
<span class="sd">            additionally. If True, theta must not be None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        log_likelihood : float</span>
<span class="sd">            Log-marginal likelihood of theta for training data.</span>

<span class="sd">        log_likelihood_gradient : array, shape = (n_kernel_params,), optional</span>
<span class="sd">            Gradient of the log-marginal likelihood with respect to the kernel</span>
<span class="sd">            hyperparameters at position theta.</span>
<span class="sd">            Only returned when eval_gradient is True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">theta</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">eval_gradient</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Gradient can only be evaluated for theta!=None&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_marginal_likelihood_value_</span>

        <span class="n">kernel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel_</span><span class="o">.</span><span class="n">clone_with_theta</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">eval_gradient</span><span class="p">:</span>
            <span class="n">K</span><span class="p">,</span> <span class="n">K_gradient</span> <span class="o">=</span> <span class="n">kernel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_train_</span><span class="p">,</span> <span class="n">eval_gradient</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">K</span> <span class="o">=</span> <span class="n">kernel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_train_</span><span class="p">)</span>

        <span class="c1"># Compute log-marginal-likelihood Z and also store some temporaries</span>
        <span class="c1"># which can be reused for computing Z&#39;s gradient</span>
        <span class="n">Z</span><span class="p">,</span> <span class="p">(</span><span class="n">pi</span><span class="p">,</span> <span class="n">W_sr</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">_posterior_mode</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">return_temporaries</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">eval_gradient</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Z</span>

        <span class="c1"># Compute gradient based on Algorithm 5.1 of GPML</span>
        <span class="n">d_Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">theta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="c1"># XXX: Get rid of the np.diag() in the next line</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">W_sr</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">cho_solve</span><span class="p">((</span><span class="n">L</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">W_sr</span><span class="p">))</span>  <span class="c1"># Line 7</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">W_sr</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">K</span><span class="p">)</span>  <span class="c1"># Line 8</span>
        <span class="c1"># Line 9: (use einsum to compute np.diag(C.T.dot(C))))</span>
        <span class="n">s_2</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">K</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij, ij -&gt; j&#39;</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">C</span><span class="p">))</span> \
            <span class="o">*</span> <span class="p">(</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span><span class="p">))</span>  <span class="c1"># third derivative</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d_Z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">K_gradient</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">j</span><span class="p">]</span>   <span class="c1"># Line 11</span>
            <span class="c1"># Line 12: (R.T.ravel().dot(C.ravel()) = np.trace(R.dot(C)))</span>
            <span class="n">s_1</span> <span class="o">=</span> <span class="o">.</span><span class="mi">5</span> <span class="o">*</span> <span class="n">a</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">C</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">-</span> <span class="o">.</span><span class="mi">5</span> <span class="o">*</span> <span class="n">R</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>

            <span class="n">b</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y_train_</span> <span class="o">-</span> <span class="n">pi</span><span class="p">)</span>  <span class="c1"># Line 13</span>
            <span class="n">s_3</span> <span class="o">=</span> <span class="n">b</span> <span class="o">-</span> <span class="n">K</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>  <span class="c1"># Line 14</span>

            <span class="n">d_Z</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">s_1</span> <span class="o">+</span> <span class="n">s_2</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">s_3</span><span class="p">)</span>  <span class="c1"># Line 15</span>

        <span class="k">return</span> <span class="n">Z</span><span class="p">,</span> <span class="n">d_Z</span>

    <span class="k">def</span> <span class="nf">_posterior_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">return_temporaries</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Mode-finding for binary Laplace GPC and fixed kernel.</span>

<span class="sd">        This approximates the posterior of the latent function values for given</span>
<span class="sd">        inputs and target observations with a Gaussian approximation and uses</span>
<span class="sd">        Newton&#39;s iteration to find the mode of this approximation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Based on Algorithm 3.1 of GPML</span>

        <span class="c1"># If warm_start are enabled, we reuse the last solution for the</span>
        <span class="c1"># posterior mode as initialization; otherwise, we initialize with 0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">warm_start</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;f_cached&quot;</span><span class="p">)</span> \
           <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">f_cached</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_train_</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f_cached</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y_train_</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="c1"># Use Newton&#39;s iteration method to find mode of Laplace approximation</span>
        <span class="n">log_marginal_likelihood</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_iter_predict</span><span class="p">):</span>
            <span class="c1"># Line 4</span>
            <span class="n">pi</span> <span class="o">=</span> <span class="n">expit</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="n">W</span> <span class="o">=</span> <span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">pi</span><span class="p">)</span>
            <span class="c1"># Line 5</span>
            <span class="n">W_sr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">W</span><span class="p">)</span>
            <span class="n">W_sr_K</span> <span class="o">=</span> <span class="n">W_sr</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">K</span>
            <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">W_sr_K</span> <span class="o">*</span> <span class="n">W_sr</span>
            <span class="n">L</span> <span class="o">=</span> <span class="n">cholesky</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># Line 6</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">W</span> <span class="o">*</span> <span class="n">f</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y_train_</span> <span class="o">-</span> <span class="n">pi</span><span class="p">)</span>
            <span class="c1"># Line 7</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">b</span> <span class="o">-</span> <span class="n">W_sr</span> <span class="o">*</span> <span class="n">cho_solve</span><span class="p">((</span><span class="n">L</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span> <span class="n">W_sr_K</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
            <span class="c1"># Line 8</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

            <span class="c1"># Line 10: Compute log marginal likelihood in loop and use as</span>
            <span class="c1">#          convergence criterion</span>
            <span class="n">lml</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">a</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> \
                <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y_train_</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">f</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> \
                <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">L</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="c1"># Check if we have converged (log marginal likelihood does</span>
            <span class="c1"># not decrease)</span>
            <span class="c1"># XXX: more complex convergence criterion</span>
            <span class="k">if</span> <span class="n">lml</span> <span class="o">-</span> <span class="n">log_marginal_likelihood</span> <span class="o">&lt;</span> <span class="mf">1e-10</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">log_marginal_likelihood</span> <span class="o">=</span> <span class="n">lml</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">f_cached</span> <span class="o">=</span> <span class="n">f</span>  <span class="c1"># Remember solution for later warm-starts</span>
        <span class="k">if</span> <span class="n">return_temporaries</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">log_marginal_likelihood</span><span class="p">,</span> <span class="p">(</span><span class="n">pi</span><span class="p">,</span> <span class="n">W_sr</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">log_marginal_likelihood</span>

    <span class="k">def</span> <span class="nf">_constrained_optimization</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj_func</span><span class="p">,</span> <span class="n">initial_theta</span><span class="p">,</span> <span class="n">bounds</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimizer</span> <span class="o">==</span> <span class="s2">&quot;fmin_l_bfgs_b&quot;</span><span class="p">:</span>
            <span class="n">theta_opt</span><span class="p">,</span> <span class="n">func_min</span><span class="p">,</span> <span class="n">convergence_dict</span> <span class="o">=</span> \
                <span class="n">fmin_l_bfgs_b</span><span class="p">(</span><span class="n">obj_func</span><span class="p">,</span> <span class="n">initial_theta</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">convergence_dict</span><span class="p">[</span><span class="s2">&quot;warnflag&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;fmin_l_bfgs_b terminated abnormally with the &quot;</span>
                              <span class="s2">&quot; state: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">convergence_dict</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optimizer</span><span class="p">):</span>
            <span class="n">theta_opt</span><span class="p">,</span> <span class="n">func_min</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">optimizer</span><span class="p">(</span><span class="n">obj_func</span><span class="p">,</span> <span class="n">initial_theta</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown optimizer </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimizer</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">theta_opt</span><span class="p">,</span> <span class="n">func_min</span>


<span class="k">class</span> <span class="nc">GaussianProcessClassifier</span><span class="p">(</span><span class="n">BaseEstimator</span><span class="p">,</span> <span class="n">ClassifierMixin</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Gaussian process classification (GPC) based on Laplace approximation.</span>

<span class="sd">    The implementation is based on Algorithm 3.1, 3.2, and 5.1 of</span>
<span class="sd">    Gaussian Processes for Machine Learning (GPML) by Rasmussen and</span>
<span class="sd">    Williams.</span>

<span class="sd">    Internally, the Laplace approximation is used for approximating the</span>
<span class="sd">    non-Gaussian posterior by a Gaussian.</span>

<span class="sd">    Currently, the implementation is restricted to using the logistic link</span>
<span class="sd">    function. For multi-class classification, several binary one-versus rest</span>
<span class="sd">    classifiers are fitted. Note that this class thus does not implement</span>
<span class="sd">    a true multi-class Laplace approximation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    kernel : kernel object</span>
<span class="sd">        The kernel specifying the covariance function of the GP. If None is</span>
<span class="sd">        passed, the kernel &quot;1.0 * RBF(1.0)&quot; is used as default. Note that</span>
<span class="sd">        the kernel&#39;s hyperparameters are optimized during fitting.</span>

<span class="sd">    optimizer : string or callable, optional (default: &quot;fmin_l_bfgs_b&quot;)</span>
<span class="sd">        Can either be one of the internally supported optimizers for optimizing</span>
<span class="sd">        the kernel&#39;s parameters, specified by a string, or an externally</span>
<span class="sd">        defined optimizer passed as a callable. If a callable is passed, it</span>
<span class="sd">        must have the  signature::</span>

<span class="sd">            def optimizer(obj_func, initial_theta, bounds):</span>
<span class="sd">                # * &#39;obj_func&#39; is the objective function to be maximized, which</span>
<span class="sd">                #   takes the hyperparameters theta as parameter and an</span>
<span class="sd">                #   optional flag eval_gradient, which determines if the</span>
<span class="sd">                #   gradient is returned additionally to the function value</span>
<span class="sd">                # * &#39;initial_theta&#39;: the initial value for theta, which can be</span>
<span class="sd">                #   used by local optimizers</span>
<span class="sd">                # * &#39;bounds&#39;: the bounds on the values of theta</span>
<span class="sd">                ....</span>
<span class="sd">                # Returned are the best found hyperparameters theta and</span>
<span class="sd">                # the corresponding value of the target function.</span>
<span class="sd">                return theta_opt, func_min</span>

<span class="sd">        Per default, the &#39;fmin_l_bfgs_b&#39; algorithm from scipy.optimize</span>
<span class="sd">        is used. If None is passed, the kernel&#39;s parameters are kept fixed.</span>
<span class="sd">        Available internal optimizers are::</span>

<span class="sd">            &#39;fmin_l_bfgs_b&#39;</span>

<span class="sd">    n_restarts_optimizer : int, optional (default: 0)</span>
<span class="sd">        The number of restarts of the optimizer for finding the kernel&#39;s</span>
<span class="sd">        parameters which maximize the log-marginal likelihood. The first run</span>
<span class="sd">        of the optimizer is performed from the kernel&#39;s initial parameters,</span>
<span class="sd">        the remaining ones (if any) from thetas sampled log-uniform randomly</span>
<span class="sd">        from the space of allowed theta-values. If greater than 0, all bounds</span>
<span class="sd">        must be finite. Note that n_restarts_optimizer=0 implies that one</span>
<span class="sd">        run is performed.</span>

<span class="sd">    max_iter_predict : int, optional (default: 100)</span>
<span class="sd">        The maximum number of iterations in Newton&#39;s method for approximating</span>
<span class="sd">        the posterior during predict. Smaller values will reduce computation</span>
<span class="sd">        time at the cost of worse results.</span>

<span class="sd">    warm_start : bool, optional (default: False)</span>
<span class="sd">        If warm-starts are enabled, the solution of the last Newton iteration</span>
<span class="sd">        on the Laplace approximation of the posterior mode is used as</span>
<span class="sd">        initialization for the next call of _posterior_mode(). This can speed</span>
<span class="sd">        up convergence when _posterior_mode is called several times on similar</span>
<span class="sd">        problems as in hyperparameter optimization.</span>

<span class="sd">    copy_X_train : bool, optional (default: True)</span>
<span class="sd">        If True, a persistent copy of the training data is stored in the</span>
<span class="sd">        object. Otherwise, just a reference to the training data is stored,</span>
<span class="sd">        which might cause predictions to change if the data is modified</span>
<span class="sd">        externally.</span>

<span class="sd">    random_state : int, RandomState instance or None, optional (default: None)</span>
<span class="sd">        The generator used to initialize the centers.</span>
<span class="sd">        If int, random_state is the seed used by the random number generator;</span>
<span class="sd">        If RandomState instance, random_state is the random number generator;</span>
<span class="sd">        If None, the random number generator is the RandomState instance used</span>
<span class="sd">        by `np.random`.</span>

<span class="sd">    multi_class : string, default : &quot;one_vs_rest&quot;</span>
<span class="sd">        Specifies how multi-class classification problems are handled.</span>
<span class="sd">        Supported are &quot;one_vs_rest&quot; and &quot;one_vs_one&quot;. In &quot;one_vs_rest&quot;,</span>
<span class="sd">        one binary Gaussian process classifier is fitted for each class, which</span>
<span class="sd">        is trained to separate this class from the rest. In &quot;one_vs_one&quot;, one</span>
<span class="sd">        binary Gaussian process classifier is fitted for each pair of classes,</span>
<span class="sd">        which is trained to separate these two classes. The predictions of</span>
<span class="sd">        these binary predictors are combined into multi-class predictions.</span>
<span class="sd">        Note that &quot;one_vs_one&quot; does not support predicting probability</span>
<span class="sd">        estimates.</span>

<span class="sd">    n_jobs : int, optional, default: 1</span>
<span class="sd">        The number of jobs to use for the computation. If -1 all CPUs are used.</span>
<span class="sd">        If 1 is given, no parallel computing code is used at all, which is</span>
<span class="sd">        useful for debugging. For n_jobs below -1, (n_cpus + 1 + n_jobs) are</span>
<span class="sd">        used. Thus for n_jobs = -2, all CPUs but one are used.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    kernel_ : kernel object</span>
<span class="sd">        The kernel used for prediction. In case of binary classification,</span>
<span class="sd">        the structure of the kernel is the same as the one passed as parameter</span>
<span class="sd">        but with optimized hyperparameters. In case of multi-class</span>
<span class="sd">        classification, a CompoundKernel is returned which consists of the</span>
<span class="sd">        different kernels used in the one-versus-rest classifiers.</span>

<span class="sd">    log_marginal_likelihood_value_ : float</span>
<span class="sd">        The log-marginal-likelihood of ``self.kernel_.theta``</span>

<span class="sd">    classes_ : array-like, shape = (n_classes,)</span>
<span class="sd">        Unique class labels.</span>

<span class="sd">    n_classes_ : int</span>
<span class="sd">        The number of classes in the training data</span>

<span class="sd">    .. versionadded:: 0.18</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kernel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">optimizer</span><span class="o">=</span><span class="s2">&quot;fmin_l_bfgs_b&quot;</span><span class="p">,</span>
                 <span class="n">n_restarts_optimizer</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_iter_predict</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
                 <span class="n">warm_start</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">copy_X_train</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">multi_class</span><span class="o">=</span><span class="s2">&quot;one_vs_rest&quot;</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kernel</span> <span class="o">=</span> <span class="n">kernel</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optimizer</span> <span class="o">=</span> <span class="n">optimizer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_restarts_optimizer</span> <span class="o">=</span> <span class="n">n_restarts_optimizer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_iter_predict</span> <span class="o">=</span> <span class="n">max_iter_predict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">warm_start</span> <span class="o">=</span> <span class="n">warm_start</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">copy_X_train</span> <span class="o">=</span> <span class="n">copy_X_train</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">random_state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">multi_class</span> <span class="o">=</span> <span class="n">multi_class</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span> <span class="o">=</span> <span class="n">n_jobs</span>

<div class="viewcode-block" id="GaussianProcessClassifier.fit"><a class="viewcode-back" href="../../../tmp/api_ibex_sklearn_gaussian_process_gaussianprocessclassifier.html#ibex.sklearn.gaussian_process.GaussianProcessClassifier.fit">[docs]</a>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fit Gaussian process classification model</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : array-like, shape = (n_samples, n_features)</span>
<span class="sd">            Training data</span>

<span class="sd">        y : array-like, shape = (n_samples,)</span>
<span class="sd">            Target values, must be binary</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self : returns an instance of self.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">check_X_y</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">multi_output</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">base_estimator_</span> <span class="o">=</span> <span class="n">_BinaryGaussianProcessClassifierLaplace</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kernel</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimizer</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_restarts_optimizer</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_iter_predict</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">warm_start</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy_X_train</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">classes_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_classes_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">classes_</span><span class="o">.</span><span class="n">size</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_classes_</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;GaussianProcessClassifier requires 2 or more &quot;</span>
                             <span class="s2">&quot;distinct classes. Only class </span><span class="si">%s</span><span class="s2"> present.&quot;</span>
                             <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">classes_</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_classes_</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">multi_class</span> <span class="o">==</span> <span class="s2">&quot;one_vs_rest&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">base_estimator_</span> <span class="o">=</span> \
                    <span class="n">OneVsRestClassifier</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_estimator_</span><span class="p">,</span>
                                        <span class="n">n_jobs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">multi_class</span> <span class="o">==</span> <span class="s2">&quot;one_vs_one&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">base_estimator_</span> <span class="o">=</span> \
                    <span class="n">OneVsOneClassifier</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_estimator_</span><span class="p">,</span>
                                       <span class="n">n_jobs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown multi-class mode </span><span class="si">%s</span><span class="s2">&quot;</span>
                                 <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">multi_class</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">base_estimator_</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_classes_</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log_marginal_likelihood_value_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span>
                <span class="p">[</span><span class="n">estimator</span><span class="o">.</span><span class="n">log_marginal_likelihood</span><span class="p">()</span>
                 <span class="k">for</span> <span class="n">estimator</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_estimator_</span><span class="o">.</span><span class="n">estimators_</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log_marginal_likelihood_value_</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">base_estimator_</span><span class="o">.</span><span class="n">log_marginal_likelihood</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="GaussianProcessClassifier.predict"><a class="viewcode-back" href="../../../tmp/api_ibex_sklearn_gaussian_process_gaussianprocessclassifier.html#ibex.sklearn.gaussian_process.GaussianProcessClassifier.predict">[docs]</a>    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform classification on an array of test vectors X.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : array-like, shape = (n_samples, n_features)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        C : array, shape = (n_samples,)</span>
<span class="sd">            Predicted target values for X, values are from ``classes_``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">check_is_fitted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;classes_&quot;</span><span class="p">,</span> <span class="s2">&quot;n_classes_&quot;</span><span class="p">])</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">check_array</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_estimator_</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">)</span></div>

<div class="viewcode-block" id="GaussianProcessClassifier.predict_proba"><a class="viewcode-back" href="../../../tmp/api_ibex_sklearn_gaussian_process_gaussianprocessclassifier.html#ibex.sklearn.gaussian_process.GaussianProcessClassifier.predict_proba">[docs]</a>    <span class="k">def</span> <span class="nf">predict_proba</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return probability estimates for the test vector X.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : array-like, shape = (n_samples, n_features)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        C : array-like, shape = (n_samples, n_classes)</span>
<span class="sd">            Returns the probability of the samples for each class in</span>
<span class="sd">            the model. The columns correspond to the classes in sorted</span>
<span class="sd">            order, as they appear in the attribute `classes_`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">check_is_fitted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;classes_&quot;</span><span class="p">,</span> <span class="s2">&quot;n_classes_&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_classes_</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">multi_class</span> <span class="o">==</span> <span class="s2">&quot;one_vs_one&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;one_vs_one multi-class mode does not support &quot;</span>
                             <span class="s2">&quot;predicting probability estimates. Use &quot;</span>
                             <span class="s2">&quot;one_vs_rest mode instead.&quot;</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">check_array</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_estimator_</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">X</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">kernel_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_classes_</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_estimator_</span><span class="o">.</span><span class="n">kernel_</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">CompoundKernel</span><span class="p">(</span>
                <span class="p">[</span><span class="n">estimator</span><span class="o">.</span><span class="n">kernel_</span>
                 <span class="k">for</span> <span class="n">estimator</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_estimator_</span><span class="o">.</span><span class="n">estimators_</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">log_marginal_likelihood</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">eval_gradient</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns log-marginal likelihood of theta for training data.</span>

<span class="sd">        In the case of multi-class classification, the mean log-marginal</span>
<span class="sd">        likelihood of the one-versus-rest classifiers are returned.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        theta : array-like, shape = (n_kernel_params,) or none</span>
<span class="sd">            Kernel hyperparameters for which the log-marginal likelihood is</span>
<span class="sd">            evaluated. In the case of multi-class classification, theta may</span>
<span class="sd">            be the  hyperparameters of the compound kernel or of an individual</span>
<span class="sd">            kernel. In the latter case, all individual kernel get assigned the</span>
<span class="sd">            same theta values. If None, the precomputed log_marginal_likelihood</span>
<span class="sd">            of ``self.kernel_.theta`` is returned.</span>

<span class="sd">        eval_gradient : bool, default: False</span>
<span class="sd">            If True, the gradient of the log-marginal likelihood with respect</span>
<span class="sd">            to the kernel hyperparameters at position theta is returned</span>
<span class="sd">            additionally. Note that gradient computation is not supported</span>
<span class="sd">            for non-binary classification. If True, theta must not be None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        log_likelihood : float</span>
<span class="sd">            Log-marginal likelihood of theta for training data.</span>

<span class="sd">        log_likelihood_gradient : array, shape = (n_kernel_params,), optional</span>
<span class="sd">            Gradient of the log-marginal likelihood with respect to the kernel</span>
<span class="sd">            hyperparameters at position theta.</span>
<span class="sd">            Only returned when eval_gradient is True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">check_is_fitted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;classes_&quot;</span><span class="p">,</span> <span class="s2">&quot;n_classes_&quot;</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">theta</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">eval_gradient</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Gradient can only be evaluated for theta!=None&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_marginal_likelihood_value_</span>

        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_classes_</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_estimator_</span><span class="o">.</span><span class="n">log_marginal_likelihood</span><span class="p">(</span>
                <span class="n">theta</span><span class="p">,</span> <span class="n">eval_gradient</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">eval_gradient</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="s2">&quot;Gradient of log-marginal-likelihood not implemented for &quot;</span>
                    <span class="s2">&quot;multi-class GPC.&quot;</span><span class="p">)</span>
            <span class="n">estimators</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_estimator_</span><span class="o">.</span><span class="n">estimators_</span>
            <span class="n">n_dims</span> <span class="o">=</span> <span class="n">estimators</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">kernel_</span><span class="o">.</span><span class="n">n_dims</span>
            <span class="k">if</span> <span class="n">theta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">n_dims</span><span class="p">:</span>  <span class="c1"># use same theta for all sub-kernels</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">estimator</span><span class="o">.</span><span class="n">log_marginal_likelihood</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">estimator</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">estimators</span><span class="p">)])</span>
            <span class="k">elif</span> <span class="n">theta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">n_dims</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">classes_</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="c1"># theta for compound kernel</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">estimator</span><span class="o">.</span><span class="n">log_marginal_likelihood</span><span class="p">(</span>
                        <span class="n">theta</span><span class="p">[</span><span class="n">n_dims</span> <span class="o">*</span> <span class="n">i</span><span class="p">:</span><span class="n">n_dims</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span>
                     <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">estimator</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">estimators</span><span class="p">)])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Shape of theta must be either </span><span class="si">%d</span><span class="s2"> or </span><span class="si">%d</span><span class="s2">. &quot;</span>
                                 <span class="s2">&quot;Obtained theta with shape </span><span class="si">%d</span><span class="s2">.&quot;</span>
                                 <span class="o">%</span> <span class="p">(</span><span class="n">n_dims</span><span class="p">,</span> <span class="n">n_dims</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">classes_</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                    <span class="n">theta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/logo.jpeg" alt="Logo"/>
            </a></p><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Ami Tavory, Shahar Azulay, Tali Raveh-Sadka.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.6.5</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
    </div>

    
    <a href="https://github.com/atavory/ibex" class="github">
        <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"  class="github"/>
    </a>
    

    
  </body>
</html>