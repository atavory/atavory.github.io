
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>sklearn.cluster.birch &#8212; ibex latest documentation</title>
    <link rel="stylesheet" href="../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     'latest',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../../../_static/logo.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for sklearn.cluster.birch</h1><div class="highlight"><pre>
<span></span><span class="c1"># Authors: Manoj Kumar &lt;manojkumarsivaraj334@gmail.com&gt;</span>
<span class="c1">#          Alexandre Gramfort &lt;alexandre.gramfort@telecom-paristech.fr&gt;</span>
<span class="c1">#          Joel Nothman &lt;joel.nothman@gmail.com&gt;</span>
<span class="c1"># License: BSD 3 clause</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span>

<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">sparse</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="k">import</span> <span class="n">sqrt</span>

<span class="kn">from</span> <span class="nn">..metrics.pairwise</span> <span class="k">import</span> <span class="n">euclidean_distances</span>
<span class="kn">from</span> <span class="nn">..base</span> <span class="k">import</span> <span class="n">TransformerMixin</span><span class="p">,</span> <span class="n">ClusterMixin</span><span class="p">,</span> <span class="n">BaseEstimator</span>
<span class="kn">from</span> <span class="nn">..externals.six.moves</span> <span class="k">import</span> <span class="n">xrange</span>
<span class="kn">from</span> <span class="nn">..utils</span> <span class="k">import</span> <span class="n">check_array</span>
<span class="kn">from</span> <span class="nn">..utils.extmath</span> <span class="k">import</span> <span class="n">row_norms</span><span class="p">,</span> <span class="n">safe_sparse_dot</span>
<span class="kn">from</span> <span class="nn">..utils.validation</span> <span class="k">import</span> <span class="n">check_is_fitted</span>
<span class="kn">from</span> <span class="nn">..exceptions</span> <span class="k">import</span> <span class="n">NotFittedError</span>
<span class="kn">from</span> <span class="nn">.hierarchical</span> <span class="k">import</span> <span class="n">AgglomerativeClustering</span>


<span class="k">def</span> <span class="nf">_iterate_sparse_X</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This little hack returns a densified row when iterating over a sparse</span>
<span class="sd">    matrix, instead of constructing a sparse matrix for every row that is</span>
<span class="sd">    expensive.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n_samples</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">X_indices</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">indices</span>
    <span class="n">X_data</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">data</span>
    <span class="n">X_indptr</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">indptr</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">n_samples</span><span class="p">):</span>
        <span class="n">row</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">startptr</span><span class="p">,</span> <span class="n">endptr</span> <span class="o">=</span> <span class="n">X_indptr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">X_indptr</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">nonzero_indices</span> <span class="o">=</span> <span class="n">X_indices</span><span class="p">[</span><span class="n">startptr</span><span class="p">:</span><span class="n">endptr</span><span class="p">]</span>
        <span class="n">row</span><span class="p">[</span><span class="n">nonzero_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">X_data</span><span class="p">[</span><span class="n">startptr</span><span class="p">:</span><span class="n">endptr</span><span class="p">]</span>
        <span class="k">yield</span> <span class="n">row</span>


<span class="k">def</span> <span class="nf">_split_node</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">branching_factor</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The node has to be split if there is no place for a new subcluster</span>
<span class="sd">    in the node.</span>
<span class="sd">    1. Two empty nodes and two empty subclusters are initialized.</span>
<span class="sd">    2. The pair of distant subclusters are found.</span>
<span class="sd">    3. The properties of the empty subclusters and nodes are updated</span>
<span class="sd">       according to the nearest distance between the subclusters to the</span>
<span class="sd">       pair of distant subclusters.</span>
<span class="sd">    4. The two nodes are set as children to the two subclusters.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">new_subcluster1</span> <span class="o">=</span> <span class="n">_CFSubcluster</span><span class="p">()</span>
    <span class="n">new_subcluster2</span> <span class="o">=</span> <span class="n">_CFSubcluster</span><span class="p">()</span>
    <span class="n">new_node1</span> <span class="o">=</span> <span class="n">_CFNode</span><span class="p">(</span>
        <span class="n">threshold</span><span class="p">,</span> <span class="n">branching_factor</span><span class="p">,</span> <span class="n">is_leaf</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">,</span>
        <span class="n">n_features</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">n_features</span><span class="p">)</span>
    <span class="n">new_node2</span> <span class="o">=</span> <span class="n">_CFNode</span><span class="p">(</span>
        <span class="n">threshold</span><span class="p">,</span> <span class="n">branching_factor</span><span class="p">,</span> <span class="n">is_leaf</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">,</span>
        <span class="n">n_features</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">n_features</span><span class="p">)</span>
    <span class="n">new_subcluster1</span><span class="o">.</span><span class="n">child_</span> <span class="o">=</span> <span class="n">new_node1</span>
    <span class="n">new_subcluster2</span><span class="o">.</span><span class="n">child_</span> <span class="o">=</span> <span class="n">new_node2</span>

    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">prev_leaf_</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">node</span><span class="o">.</span><span class="n">prev_leaf_</span><span class="o">.</span><span class="n">next_leaf_</span> <span class="o">=</span> <span class="n">new_node1</span>
        <span class="n">new_node1</span><span class="o">.</span><span class="n">prev_leaf_</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">prev_leaf_</span>
        <span class="n">new_node1</span><span class="o">.</span><span class="n">next_leaf_</span> <span class="o">=</span> <span class="n">new_node2</span>
        <span class="n">new_node2</span><span class="o">.</span><span class="n">prev_leaf_</span> <span class="o">=</span> <span class="n">new_node1</span>
        <span class="n">new_node2</span><span class="o">.</span><span class="n">next_leaf_</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">next_leaf_</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">next_leaf_</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">node</span><span class="o">.</span><span class="n">next_leaf_</span><span class="o">.</span><span class="n">prev_leaf_</span> <span class="o">=</span> <span class="n">new_node2</span>

    <span class="n">dist</span> <span class="o">=</span> <span class="n">euclidean_distances</span><span class="p">(</span>
        <span class="n">node</span><span class="o">.</span><span class="n">centroids_</span><span class="p">,</span> <span class="n">Y_norm_squared</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">squared_norm_</span><span class="p">,</span> <span class="n">squared</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">n_clusters</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">farthest_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span>
        <span class="n">dist</span><span class="o">.</span><span class="n">argmax</span><span class="p">(),</span> <span class="p">(</span><span class="n">n_clusters</span><span class="p">,</span> <span class="n">n_clusters</span><span class="p">))</span>
    <span class="n">node1_dist</span><span class="p">,</span> <span class="n">node2_dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[[</span><span class="n">farthest_idx</span><span class="p">]]</span>

    <span class="n">node1_closer</span> <span class="o">=</span> <span class="n">node1_dist</span> <span class="o">&lt;</span> <span class="n">node2_dist</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">subcluster</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">subclusters_</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">node1_closer</span><span class="p">[</span><span class="n">idx</span><span class="p">]:</span>
            <span class="n">new_node1</span><span class="o">.</span><span class="n">append_subcluster</span><span class="p">(</span><span class="n">subcluster</span><span class="p">)</span>
            <span class="n">new_subcluster1</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">subcluster</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_node2</span><span class="o">.</span><span class="n">append_subcluster</span><span class="p">(</span><span class="n">subcluster</span><span class="p">)</span>
            <span class="n">new_subcluster2</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">subcluster</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">new_subcluster1</span><span class="p">,</span> <span class="n">new_subcluster2</span>


<span class="k">class</span> <span class="nc">_CFNode</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Each node in a CFTree is called a CFNode.</span>

<span class="sd">    The CFNode can have a maximum of branching_factor</span>
<span class="sd">    number of CFSubclusters.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    threshold : float</span>
<span class="sd">        Threshold needed for a new subcluster to enter a CFSubcluster.</span>

<span class="sd">    branching_factor : int</span>
<span class="sd">        Maximum number of CF subclusters in each node.</span>

<span class="sd">    is_leaf : bool</span>
<span class="sd">        We need to know if the CFNode is a leaf or not, in order to</span>
<span class="sd">        retrieve the final subclusters.</span>

<span class="sd">    n_features : int</span>
<span class="sd">        The number of features.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    subclusters_ : array-like</span>
<span class="sd">        list of subclusters for a particular CFNode.</span>

<span class="sd">    prev_leaf_ : _CFNode</span>
<span class="sd">        prev_leaf. Useful only if is_leaf is True.</span>

<span class="sd">    next_leaf_ : _CFNode</span>
<span class="sd">        next_leaf. Useful only if is_leaf is True.</span>
<span class="sd">        the final subclusters.</span>

<span class="sd">    init_centroids_ : ndarray, shape (branching_factor + 1, n_features)</span>
<span class="sd">        manipulate ``init_centroids_`` throughout rather than centroids_ since</span>
<span class="sd">        the centroids are just a view of the ``init_centroids_`` .</span>

<span class="sd">    init_sq_norm_ : ndarray, shape (branching_factor + 1,)</span>
<span class="sd">        manipulate init_sq_norm_ throughout. similar to ``init_centroids_``.</span>

<span class="sd">    centroids_ : ndarray</span>
<span class="sd">        view of ``init_centroids_``.</span>

<span class="sd">    squared_norm_ : ndarray</span>
<span class="sd">        view of ``init_sq_norm_``.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">branching_factor</span><span class="p">,</span> <span class="n">is_leaf</span><span class="p">,</span> <span class="n">n_features</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span> <span class="o">=</span> <span class="n">threshold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">branching_factor</span> <span class="o">=</span> <span class="n">branching_factor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_leaf</span> <span class="o">=</span> <span class="n">is_leaf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_features</span> <span class="o">=</span> <span class="n">n_features</span>

        <span class="c1"># The list of subclusters, centroids and squared norms</span>
        <span class="c1"># to manipulate throughout.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subclusters_</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_centroids_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">branching_factor</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_features</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_sq_norm_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">branching_factor</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">squared_norm_</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prev_leaf_</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next_leaf_</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">append_subcluster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subcluster</span><span class="p">):</span>
        <span class="n">n_samples</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subclusters_</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subclusters_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subcluster</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_centroids_</span><span class="p">[</span><span class="n">n_samples</span><span class="p">]</span> <span class="o">=</span> <span class="n">subcluster</span><span class="o">.</span><span class="n">centroid_</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_sq_norm_</span><span class="p">[</span><span class="n">n_samples</span><span class="p">]</span> <span class="o">=</span> <span class="n">subcluster</span><span class="o">.</span><span class="n">sq_norm_</span>

        <span class="c1"># Keep centroids and squared norm as views. In this way</span>
        <span class="c1"># if we change init_centroids and init_sq_norm_, it is</span>
        <span class="c1"># sufficient,</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">centroids_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_centroids_</span><span class="p">[:</span><span class="n">n_samples</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">squared_norm_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_sq_norm_</span><span class="p">[:</span><span class="n">n_samples</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">update_split_subclusters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subcluster</span><span class="p">,</span>
                                 <span class="n">new_subcluster1</span><span class="p">,</span> <span class="n">new_subcluster2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove a subcluster from a node and update it with the</span>
<span class="sd">        split subclusters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subclusters_</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">subcluster</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subclusters_</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_subcluster1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_centroids_</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_subcluster1</span><span class="o">.</span><span class="n">centroid_</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_sq_norm_</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_subcluster1</span><span class="o">.</span><span class="n">sq_norm_</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">append_subcluster</span><span class="p">(</span><span class="n">new_subcluster2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">insert_cf_subcluster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subcluster</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Insert a new subcluster into the node.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">subclusters_</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">append_subcluster</span><span class="p">(</span><span class="n">subcluster</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">threshold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span>
        <span class="n">branching_factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">branching_factor</span>
        <span class="c1"># We need to find the closest subcluster among all the</span>
        <span class="c1"># subclusters so that we can insert our new subcluster.</span>
        <span class="n">dist_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">centroids_</span><span class="p">,</span> <span class="n">subcluster</span><span class="o">.</span><span class="n">centroid_</span><span class="p">)</span>
        <span class="n">dist_matrix</span> <span class="o">*=</span> <span class="o">-</span><span class="mf">2.</span>
        <span class="n">dist_matrix</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">squared_norm_</span>
        <span class="n">closest_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dist_matrix</span><span class="p">)</span>
        <span class="n">closest_subcluster</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subclusters_</span><span class="p">[</span><span class="n">closest_index</span><span class="p">]</span>

        <span class="c1"># If the subcluster has a child, we need a recursive strategy.</span>
        <span class="k">if</span> <span class="n">closest_subcluster</span><span class="o">.</span><span class="n">child_</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">split_child</span> <span class="o">=</span> <span class="n">closest_subcluster</span><span class="o">.</span><span class="n">child_</span><span class="o">.</span><span class="n">insert_cf_subcluster</span><span class="p">(</span>
                <span class="n">subcluster</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">split_child</span><span class="p">:</span>
                <span class="c1"># If it is determined that the child need not be split, we</span>
                <span class="c1"># can just update the closest_subcluster</span>
                <span class="n">closest_subcluster</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">subcluster</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">init_centroids_</span><span class="p">[</span><span class="n">closest_index</span><span class="p">]</span> <span class="o">=</span> \
                    <span class="bp">self</span><span class="o">.</span><span class="n">subclusters_</span><span class="p">[</span><span class="n">closest_index</span><span class="p">]</span><span class="o">.</span><span class="n">centroid_</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">init_sq_norm_</span><span class="p">[</span><span class="n">closest_index</span><span class="p">]</span> <span class="o">=</span> \
                    <span class="bp">self</span><span class="o">.</span><span class="n">subclusters_</span><span class="p">[</span><span class="n">closest_index</span><span class="p">]</span><span class="o">.</span><span class="n">sq_norm_</span>
                <span class="k">return</span> <span class="kc">False</span>

            <span class="c1"># things not too good. we need to redistribute the subclusters in</span>
            <span class="c1"># our child node, and add a new subcluster in the parent</span>
            <span class="c1"># subcluster to accommodate the new child.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_subcluster1</span><span class="p">,</span> <span class="n">new_subcluster2</span> <span class="o">=</span> <span class="n">_split_node</span><span class="p">(</span>
                    <span class="n">closest_subcluster</span><span class="o">.</span><span class="n">child_</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">branching_factor</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update_split_subclusters</span><span class="p">(</span>
                    <span class="n">closest_subcluster</span><span class="p">,</span> <span class="n">new_subcluster1</span><span class="p">,</span> <span class="n">new_subcluster2</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subclusters_</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">branching_factor</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span>
                <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># good to go!</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">merged</span> <span class="o">=</span> <span class="n">closest_subcluster</span><span class="o">.</span><span class="n">merge_subcluster</span><span class="p">(</span>
                <span class="n">subcluster</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">merged</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">init_centroids_</span><span class="p">[</span><span class="n">closest_index</span><span class="p">]</span> <span class="o">=</span> \
                    <span class="n">closest_subcluster</span><span class="o">.</span><span class="n">centroid_</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">init_sq_norm_</span><span class="p">[</span><span class="n">closest_index</span><span class="p">]</span> <span class="o">=</span> \
                    <span class="n">closest_subcluster</span><span class="o">.</span><span class="n">sq_norm_</span>
                <span class="k">return</span> <span class="kc">False</span>

            <span class="c1"># not close to any other subclusters, and we still</span>
            <span class="c1"># have space, so add.</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subclusters_</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">branching_factor</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">append_subcluster</span><span class="p">(</span><span class="n">subcluster</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">False</span>

            <span class="c1"># We do not have enough space nor is it closer to an</span>
            <span class="c1"># other subcluster. We need to split.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">append_subcluster</span><span class="p">(</span><span class="n">subcluster</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">True</span>


<span class="k">class</span> <span class="nc">_CFSubcluster</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Each subcluster in a CFNode is called a CFSubcluster.</span>

<span class="sd">    A CFSubcluster can have a CFNode has its child.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    linear_sum : ndarray, shape (n_features,), optional</span>
<span class="sd">        Sample. This is kept optional to allow initialization of empty</span>
<span class="sd">        subclusters.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    n_samples_ : int</span>
<span class="sd">        Number of samples that belong to each subcluster.</span>

<span class="sd">    linear_sum_ : ndarray</span>
<span class="sd">        Linear sum of all the samples in a subcluster. Prevents holding</span>
<span class="sd">        all sample data in memory.</span>

<span class="sd">    squared_sum_ : float</span>
<span class="sd">        Sum of the squared l2 norms of all samples belonging to a subcluster.</span>

<span class="sd">    centroid_ : ndarray</span>
<span class="sd">        Centroid of the subcluster. Prevent recomputing of centroids when</span>
<span class="sd">        ``CFNode.centroids_`` is called.</span>

<span class="sd">    child_ : _CFNode</span>
<span class="sd">        Child Node of the subcluster. Once a given _CFNode is set as the child</span>
<span class="sd">        of the _CFNode, it is set to ``self.child_``.</span>

<span class="sd">    sq_norm_ : ndarray</span>
<span class="sd">        Squared norm of the subcluster. Used to prevent recomputing when</span>
<span class="sd">        pairwise minimum distances are computed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linear_sum</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">linear_sum</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_samples_</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">squared_sum_</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">linear_sum_</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_samples_</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">centroid_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">linear_sum_</span> <span class="o">=</span> <span class="n">linear_sum</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">squared_sum_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sq_norm_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">linear_sum_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">linear_sum_</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">child_</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subcluster</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_samples_</span> <span class="o">+=</span> <span class="n">subcluster</span><span class="o">.</span><span class="n">n_samples_</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linear_sum_</span> <span class="o">+=</span> <span class="n">subcluster</span><span class="o">.</span><span class="n">linear_sum_</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">squared_sum_</span> <span class="o">+=</span> <span class="n">subcluster</span><span class="o">.</span><span class="n">squared_sum_</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">centroid_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">linear_sum_</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_samples_</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sq_norm_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">centroid_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">centroid_</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">merge_subcluster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nominee_cluster</span><span class="p">,</span> <span class="n">threshold</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if a cluster is worthy enough to be merged. If</span>
<span class="sd">        yes then merge.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_ss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">squared_sum_</span> <span class="o">+</span> <span class="n">nominee_cluster</span><span class="o">.</span><span class="n">squared_sum_</span>
        <span class="n">new_ls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">linear_sum_</span> <span class="o">+</span> <span class="n">nominee_cluster</span><span class="o">.</span><span class="n">linear_sum_</span>
        <span class="n">new_n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_samples_</span> <span class="o">+</span> <span class="n">nominee_cluster</span><span class="o">.</span><span class="n">n_samples_</span>
        <span class="n">new_centroid</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">new_n</span><span class="p">)</span> <span class="o">*</span> <span class="n">new_ls</span>
        <span class="n">new_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">new_centroid</span><span class="p">,</span> <span class="n">new_centroid</span><span class="p">)</span>
        <span class="n">dot_product</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">new_n</span><span class="p">)</span> <span class="o">*</span> <span class="n">new_norm</span>
        <span class="n">sq_radius</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_ss</span> <span class="o">+</span> <span class="n">dot_product</span><span class="p">)</span> <span class="o">/</span> <span class="n">new_n</span> <span class="o">+</span> <span class="n">new_norm</span>
        <span class="k">if</span> <span class="n">sq_radius</span> <span class="o">&lt;=</span> <span class="n">threshold</span> <span class="o">**</span> <span class="mi">2</span><span class="p">:</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_samples_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">linear_sum_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">squared_sum_</span><span class="p">,</span>
             <span class="bp">self</span><span class="o">.</span><span class="n">centroid_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sq_norm_</span><span class="p">)</span> <span class="o">=</span> \
                <span class="n">new_n</span><span class="p">,</span> <span class="n">new_ls</span><span class="p">,</span> <span class="n">new_ss</span><span class="p">,</span> <span class="n">new_centroid</span><span class="p">,</span> <span class="n">new_norm</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">radius</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return radius of the subcluster&quot;&quot;&quot;</span>
        <span class="n">dot_product</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">linear_sum_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">centroid_</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span>
            <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">squared_sum_</span> <span class="o">+</span> <span class="n">dot_product</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_samples_</span><span class="p">)</span> <span class="o">+</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sq_norm_</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Birch</span><span class="p">(</span><span class="n">BaseEstimator</span><span class="p">,</span> <span class="n">TransformerMixin</span><span class="p">,</span> <span class="n">ClusterMixin</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Implements the Birch clustering algorithm.</span>

<span class="sd">    It is a memory-efficient, online-learning algorithm provided as an</span>
<span class="sd">    alternative to :class:`MiniBatchKMeans`. It constructs a tree</span>
<span class="sd">    data structure with the cluster centroids being read off the leaf.</span>
<span class="sd">    These can be either the final cluster centroids or can be provided as input</span>
<span class="sd">    to another clustering algorithm such as :class:`AgglomerativeClustering`.</span>

<span class="sd">    Read more in the :ref:`User Guide &lt;birch&gt;`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    threshold : float, default 0.5</span>
<span class="sd">        The radius of the subcluster obtained by merging a new sample and the</span>
<span class="sd">        closest subcluster should be lesser than the threshold. Otherwise a new</span>
<span class="sd">        subcluster is started. Setting this value to be very low promotes</span>
<span class="sd">        splitting and vice-versa.</span>

<span class="sd">    branching_factor : int, default 50</span>
<span class="sd">        Maximum number of CF subclusters in each node. If a new samples enters</span>
<span class="sd">        such that the number of subclusters exceed the branching_factor then</span>
<span class="sd">        that node is split into two nodes with the subclusters redistributed</span>
<span class="sd">        in each. The parent subcluster of that node is removed and two new</span>
<span class="sd">        subclusters are added as parents of the 2 split nodes.</span>

<span class="sd">    n_clusters : int, instance of sklearn.cluster model, default 3</span>
<span class="sd">        Number of clusters after the final clustering step, which treats the</span>
<span class="sd">        subclusters from the leaves as new samples.</span>

<span class="sd">        - `None` : the final clustering step is not performed and the</span>
<span class="sd">          subclusters are returned as they are.</span>

<span class="sd">        - `sklearn.cluster` Estimator : If a model is provided, the model is</span>
<span class="sd">          fit treating the subclusters as new samples and the initial data is</span>
<span class="sd">          mapped to the label of the closest subcluster.</span>

<span class="sd">        - `int` : the model fit is :class:`AgglomerativeClustering` with</span>
<span class="sd">          `n_clusters` set to be equal to the int.</span>

<span class="sd">    compute_labels : bool, default True</span>
<span class="sd">        Whether or not to compute labels for each fit.</span>

<span class="sd">    copy : bool, default True</span>
<span class="sd">        Whether or not to make a copy of the given data. If set to False,</span>
<span class="sd">        the initial data will be overwritten.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    root_ : _CFNode</span>
<span class="sd">        Root of the CFTree.</span>

<span class="sd">    dummy_leaf_ : _CFNode</span>
<span class="sd">        Start pointer to all the leaves.</span>

<span class="sd">    subcluster_centers_ : ndarray,</span>
<span class="sd">        Centroids of all subclusters read directly from the leaves.</span>

<span class="sd">    subcluster_labels_ : ndarray,</span>
<span class="sd">        Labels assigned to the centroids of the subclusters after</span>
<span class="sd">        they are clustered globally.</span>

<span class="sd">    labels_ : ndarray, shape (n_samples,)</span>
<span class="sd">        Array of labels assigned to the input data.</span>
<span class="sd">        if partial_fit is used instead of fit, they are assigned to the</span>
<span class="sd">        last batch of data.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from sklearn.cluster import Birch</span>
<span class="sd">    &gt;&gt;&gt; X = [[0, 1], [0.3, 1], [-0.3, 1], [0, -1], [0.3, -1], [-0.3, -1]]</span>
<span class="sd">    &gt;&gt;&gt; brc = Birch(branching_factor=50, n_clusters=None, threshold=0.5,</span>
<span class="sd">    ... compute_labels=True)</span>
<span class="sd">    &gt;&gt;&gt; brc.fit(X)</span>
<span class="sd">    Birch(branching_factor=50, compute_labels=True, copy=True, n_clusters=None,</span>
<span class="sd">       threshold=0.5)</span>
<span class="sd">    &gt;&gt;&gt; brc.predict(X)</span>
<span class="sd">    array([0, 0, 0, 1, 1, 1])</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    * Tian Zhang, Raghu Ramakrishnan, Maron Livny</span>
<span class="sd">      BIRCH: An efficient data clustering method for large databases.</span>
<span class="sd">      http://www.cs.sfu.ca/CourseCentral/459/han/papers/zhang96.pdf</span>

<span class="sd">    * Roberto Perdisci</span>
<span class="sd">      JBirch - Java implementation of BIRCH clustering algorithm</span>
<span class="sd">      https://code.google.com/archive/p/jbirch</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The tree data structure consists of nodes with each node consisting of</span>
<span class="sd">    a number of subclusters. The maximum number of subclusters in a node</span>
<span class="sd">    is determined by the branching factor. Each subcluster maintains a</span>
<span class="sd">    linear sum, squared sum and the number of samples in that subcluster.</span>
<span class="sd">    In addition, each subcluster can also have a node as its child, if the</span>
<span class="sd">    subcluster is not a member of a leaf node.</span>

<span class="sd">    For a new point entering the root, it is merged with the subcluster closest</span>
<span class="sd">    to it and the linear sum, squared sum and the number of samples of that</span>
<span class="sd">    subcluster are updated. This is done recursively till the properties of</span>
<span class="sd">    the leaf node are updated.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">branching_factor</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                 <span class="n">compute_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span> <span class="o">=</span> <span class="n">threshold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">branching_factor</span> <span class="o">=</span> <span class="n">branching_factor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">=</span> <span class="n">n_clusters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compute_labels</span> <span class="o">=</span> <span class="n">compute_labels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">copy</span> <span class="o">=</span> <span class="n">copy</span>

<div class="viewcode-block" id="Birch.fit"><a class="viewcode-back" href="../../../tmp/api_ibex_sklearn_cluster_birch.html#ibex.sklearn.cluster.Birch.fit">[docs]</a>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build a CF Tree for the input data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : {array-like, sparse matrix}, shape (n_samples, n_features)</span>
<span class="sd">            Input data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">partial_fit_</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">check_array</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">accept_sparse</span><span class="o">=</span><span class="s1">&#39;csr&#39;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">)</span>
        <span class="n">threshold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span>
        <span class="n">branching_factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">branching_factor</span>

        <span class="k">if</span> <span class="n">branching_factor</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Branching_factor should be greater than one.&quot;</span><span class="p">)</span>
        <span class="n">n_samples</span><span class="p">,</span> <span class="n">n_features</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>

        <span class="c1"># If partial_fit is called for the first time or fit is called, we</span>
        <span class="c1"># start a new tree.</span>
        <span class="n">partial_fit</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;partial_fit_&#39;</span><span class="p">)</span>
        <span class="n">has_root</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;root_&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;fit_&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">partial_fit</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">has_root</span><span class="p">):</span>
            <span class="c1"># The first root is the leaf. Manipulate this object throughout.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">root_</span> <span class="o">=</span> <span class="n">_CFNode</span><span class="p">(</span><span class="n">threshold</span><span class="p">,</span> <span class="n">branching_factor</span><span class="p">,</span> <span class="n">is_leaf</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                 <span class="n">n_features</span><span class="o">=</span><span class="n">n_features</span><span class="p">)</span>

            <span class="c1"># To enable getting back subclusters.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dummy_leaf_</span> <span class="o">=</span> <span class="n">_CFNode</span><span class="p">(</span><span class="n">threshold</span><span class="p">,</span> <span class="n">branching_factor</span><span class="p">,</span>
                                       <span class="n">is_leaf</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">n_features</span><span class="o">=</span><span class="n">n_features</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dummy_leaf_</span><span class="o">.</span><span class="n">next_leaf_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">root_</span><span class="o">.</span><span class="n">prev_leaf_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dummy_leaf_</span>

        <span class="c1"># Cannot vectorize. Enough to convince to use cython.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">sparse</span><span class="o">.</span><span class="n">issparse</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
            <span class="n">iter_func</span> <span class="o">=</span> <span class="nb">iter</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">iter_func</span> <span class="o">=</span> <span class="n">_iterate_sparse_X</span>

        <span class="k">for</span> <span class="n">sample</span> <span class="ow">in</span> <span class="n">iter_func</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
            <span class="n">subcluster</span> <span class="o">=</span> <span class="n">_CFSubcluster</span><span class="p">(</span><span class="n">linear_sum</span><span class="o">=</span><span class="n">sample</span><span class="p">)</span>
            <span class="n">split</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_</span><span class="o">.</span><span class="n">insert_cf_subcluster</span><span class="p">(</span><span class="n">subcluster</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">split</span><span class="p">:</span>
                <span class="n">new_subcluster1</span><span class="p">,</span> <span class="n">new_subcluster2</span> <span class="o">=</span> <span class="n">_split_node</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">root_</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">branching_factor</span><span class="p">)</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">root_</span> <span class="o">=</span> <span class="n">_CFNode</span><span class="p">(</span><span class="n">threshold</span><span class="p">,</span> <span class="n">branching_factor</span><span class="p">,</span>
                                     <span class="n">is_leaf</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                     <span class="n">n_features</span><span class="o">=</span><span class="n">n_features</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">root_</span><span class="o">.</span><span class="n">append_subcluster</span><span class="p">(</span><span class="n">new_subcluster1</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">root_</span><span class="o">.</span><span class="n">append_subcluster</span><span class="p">(</span><span class="n">new_subcluster2</span><span class="p">)</span>

        <span class="n">centroids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span>
            <span class="n">leaf</span><span class="o">.</span><span class="n">centroids_</span> <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_leaves</span><span class="p">()])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subcluster_centers_</span> <span class="o">=</span> <span class="n">centroids</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_global_clustering</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_get_leaves</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieve the leaves of the CF Node.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        leaves : array-like</span>
<span class="sd">            List of the leaf nodes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">leaf_ptr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dummy_leaf_</span><span class="o">.</span><span class="n">next_leaf_</span>
        <span class="n">leaves</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="n">leaf_ptr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">leaves</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">leaf_ptr</span><span class="p">)</span>
            <span class="n">leaf_ptr</span> <span class="o">=</span> <span class="n">leaf_ptr</span><span class="o">.</span><span class="n">next_leaf_</span>
        <span class="k">return</span> <span class="n">leaves</span>

<div class="viewcode-block" id="Birch.partial_fit"><a class="viewcode-back" href="../../../tmp/api_ibex_sklearn_cluster_birch.html#ibex.sklearn.cluster.Birch.partial_fit">[docs]</a>    <span class="k">def</span> <span class="nf">partial_fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Online learning. Prevents rebuilding of CFTree from scratch.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : {array-like, sparse matrix}, shape (n_samples, n_features), None</span>
<span class="sd">            Input data. If X is not provided, only the global clustering</span>
<span class="sd">            step is done.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">partial_fit_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">X</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Perform just the final global clustering step.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_global_clustering</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_check_fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="n">is_fitted</span> <span class="o">=</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;subcluster_centers_&#39;</span><span class="p">)</span>

        <span class="c1"># Called by partial_fit, before fitting.</span>
        <span class="n">has_partial_fit</span> <span class="o">=</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;partial_fit_&#39;</span><span class="p">)</span>

        <span class="c1"># Should raise an error if one does not fit before predicting.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">is_fitted</span> <span class="ow">or</span> <span class="n">has_partial_fit</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">NotFittedError</span><span class="p">(</span><span class="s2">&quot;Fit training data before predicting&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">is_fitted</span> <span class="ow">and</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subcluster_centers_</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Training data and predicted data do &quot;</span>
                <span class="s2">&quot;not have same number of features.&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="Birch.predict"><a class="viewcode-back" href="../../../tmp/api_ibex_sklearn_cluster_birch.html#ibex.sklearn.cluster.Birch.predict">[docs]</a>    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Predict data using the ``centroids_`` of subclusters.</span>

<span class="sd">        Avoid computation of the row norms of X.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : {array-like, sparse matrix}, shape (n_samples, n_features)</span>
<span class="sd">            Input data.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        labels : ndarray, shape(n_samples)</span>
<span class="sd">            Labelled data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">check_array</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">accept_sparse</span><span class="o">=</span><span class="s1">&#39;csr&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">reduced_distance</span> <span class="o">=</span> <span class="n">safe_sparse_dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">subcluster_centers_</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">reduced_distance</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">2</span>
        <span class="n">reduced_distance</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subcluster_norms</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">subcluster_labels_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">reduced_distance</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span></div>

<div class="viewcode-block" id="Birch.transform"><a class="viewcode-back" href="../../../tmp/api_ibex_sklearn_cluster_birch.html#ibex.sklearn.cluster.Birch.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform X into subcluster centroids dimension.</span>

<span class="sd">        Each dimension represents the distance from the sample point to each</span>
<span class="sd">        cluster centroid.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : {array-like, sparse matrix}, shape (n_samples, n_features)</span>
<span class="sd">            Input data.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        X_trans : {array-like, sparse matrix}, shape (n_samples, n_clusters)</span>
<span class="sd">            Transformed data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">check_is_fitted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;subcluster_centers_&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">euclidean_distances</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">subcluster_centers_</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_global_clustering</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Global clustering for the subclusters obtained after fitting</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">clusterer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span>
        <span class="n">centroids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subcluster_centers_</span>
        <span class="n">compute_labels</span> <span class="o">=</span> <span class="p">(</span><span class="n">X</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_labels</span>

        <span class="c1"># Preprocessing for the global clustering.</span>
        <span class="n">not_enough_centroids</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">clusterer</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">clusterer</span> <span class="o">=</span> <span class="n">AgglomerativeClustering</span><span class="p">(</span>
                <span class="n">n_clusters</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">)</span>
            <span class="c1"># There is no need to perform the global clustering step.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">centroids</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">:</span>
                <span class="n">not_enough_centroids</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">clusterer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span>
              <span class="nb">hasattr</span><span class="p">(</span><span class="n">clusterer</span><span class="p">,</span> <span class="s1">&#39;fit_predict&#39;</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n_clusters should be an instance of &quot;</span>
                             <span class="s2">&quot;ClusterMixin or an int&quot;</span><span class="p">)</span>

        <span class="c1"># To use in predict to avoid recalculation.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_subcluster_norms</span> <span class="o">=</span> <span class="n">row_norms</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">subcluster_centers_</span><span class="p">,</span> <span class="n">squared</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">clusterer</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">not_enough_centroids</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">subcluster_labels_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">centroids</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">not_enough_centroids</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;Number of subclusters found (</span><span class="si">%d</span><span class="s2">) by Birch is less &quot;</span>
                    <span class="s2">&quot;than (</span><span class="si">%d</span><span class="s2">). Decrease the threshold.&quot;</span>
                    <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">centroids</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># The global clustering step that clusters the subclusters of</span>
            <span class="c1"># the leaves. It assumes the centroids of the subclusters as</span>
            <span class="c1"># samples and finds the final centroids.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">subcluster_labels_</span> <span class="o">=</span> <span class="n">clusterer</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">subcluster_centers_</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">compute_labels</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">labels_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/logo.jpeg" alt="Logo"/>
            </a></p><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Ami Tavory, Shahar Azulay, Tali Raveh-Sadka.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.6.5</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
    </div>

    
    <a href="https://github.com/atavory/ibex" class="github">
        <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"  class="github"/>
    </a>
    

    
  </body>
</html>